## Introduction à MySQL/MariaDB

---

MySQL et MariaDB sont des systèmes de gestion de base de données relationnelle (SGBDR) open source largement utilisés dans l'industrie. Ils offrent une solution robuste pour le stockage, la gestion et la récupération de données de manière efficace.

### Caractéristiques principales

1. **Performance élevée :** Réputé pour sa rapidité d'exécution, ce qui en fait un choix populaire pour les applications nécessitant des opérations rapides sur la base de données.

2. **Fiabilité :** Ces bases de données sont connues pour leur stabilité et leur fiabilité, ce qui en fait un choix privilégié pour les applications critiques.

3. **Open Source :**  Logiciels open source, ce qui signifie que vous pouvez les utiliser, les modifier et les distribuer librement.

> [!INFO] mysql et mariadb
> MariaDB est un fork de MySQL créé pour maintenir une alternative open source après l'acquisition de MySQL par Oracle. Les deux partagent une base commune mais diffèrent en termes de licence, communauté, et fonctionnalités.

### Installation de MySQL/MariaDB

Pour installer MySQL avec Python, vous pouvez utiliser le module `mysql-connector-python`. Utilisez la commande suivante dans votre terminal :

```bash
pip install mysql-connector-python
```

Assurez-vous également d'avoir MySQL/MariaDB installé localement ou configurez l'accès à une base de données distante.

<br>

## Utilisation Python pour MySQL/MariaDB

---

L'utilisation d'une API Python simplifie grandement les opérations sur une base de données MySQL/MariaDB. Dans cette section, nous explorerons l'utilisation du module `mysql-connector-python` comme une API Python pour interagir avec la base de données de manière plus efficace.

<br>

### 1. Établissement de la Connexion

Avant de pouvoir effectuer des opérations sur la base de données, nous devons établir une connexion en utilisant le module `mysql.connector`.

```python
import mysql.connector

# Établir la connexion
conn = mysql.connector.connect(
    host="localhost",
    user="votre_utilisateur",
    password="votre_mot_de_passe"
)
```

<br>

### 2. Création d'un Curseur

Après s'être connecté à notre base de donnée, on doit créer un curseur.
Un curseur est un objet qui nous permet d'envoyer des requêtes SQL à la base de données et de récupérer les résultats.

```python
# Créer un objet curseur
cursor = conn.cursor()
```

<br>

### 3. Création de Bases de Données et de Tables

Pour commencer nos requêtes, nous devons créer une base de données et une table pour stocker nos données. Voici comment vous pouvez le faire en utilisant Python et le module `mysql-connector-python`.

N'oubliez pas de changer le `ma_base_de_donnees` et `ma_table`.

```python
# Créer une base de données
cursor.execute("CREATE DATABASE IF NOT EXISTS ma_base_de_donnees")

# Utiliser la base de données
cursor.execute("USE ma_base_de_donnees")

# Créer une table
cursor.execute("""
    CREATE TABLE IF NOT EXISTS ma_table (
        id INT AUTO_INCREMENT PRIMARY KEY,
        nom VARCHAR(255),
        age INT
    )
""")

# Valider et appliquer les changements
conn.commit()
```

Le `commit()` permet de mettre à jour la BDD.  Si on ne le fait pas, les modification resteront en local.

> [!INFO] Importance du `commit`
> Si vous faites des modification sans commit, avec un select pour verrez les modification apporté.
> 
> Sauf que si vous lancez une autre session, les modifications ne seront pas confirmées.

<br>

### 4. Utilisation d'Opérations CRUD

- **Création (Create) :**
  ```python
  # Insérer des données dans la table
  cursor.execute("INSERT INTO ma_table (nom, age) VALUES ('John Doe', 25)")
  conn.commit()
  ```

- **Lecture (Read) :**
  ```python
  # Sélectionner toutes les données de la table
  cursor.execute("SELECT * FROM ma_table")
  result = cursor.fetchall()
  for row in result:
      print(row)
  ```

- **Mise à Jour (Update) :**
  ```python
  # Mettre à jour des données dans la table
  cursor.execute("UPDATE ma_table SET age = 26 WHERE nom = 'John Doe'")
  conn.commit()
  ```

- **Suppression (Delete) :**
  ```python
  # Supprimer des données de la table
  cursor.execute("DELETE FROM ma_table WHERE nom = 'John Doe'")
  conn.commit()
  ```

<br>

### 5. Fermeture de la Connexion

N'oubliez pas de fermer la connexion une fois que vous avez terminé vos opérations.

```python
# Fermer le curseur
cursor.close()

# Fermer la connexion
conn.close()
```

<br>

[Exercice 1](3.%20Exercices%20accès%20BDD.md#Exercice%201)

<br>


## Gestion des Erreurs et Bonnes Pratiques

---

Lors de l'accès à une base de données, il est crucial de mettre en place une gestion des erreurs efficace pour anticiper et traiter les problèmes potentiels. De plus, l'application de bonnes pratiques contribue à assurer la stabilité, la sécurité et la performance de votre code.

<br>

### 1. Gestion des Erreurs

La gestion des erreurs dans vos opérations de base de données est essentielle pour maintenir la robustesse de votre application. Utilisez des blocs `try/except` pour capturer et gérer les exceptions potentielles.

On peut ajouter le `database=` si on connais déjà notre base cible. Cela évitera faire par la suite un `USE <database>`.

```python
import mysql.connector

try:
    # Tentative d'établir une connexion
    conn = mysql.connector.connect(
        host="localhost",
        user="votre_utilisateur",
        password="votre_mot_de_passe",
        database="ma_base_de_donnees"
    )

    # Tentative d'exécution d'une requête
    cursor = conn.cursor()
    cursor.execute("SELECT * FROM ma_table")

	# Récuperer les résultats
    result = cursor.fetchall()
    for row in result:
        print(row)

except mysql.connector.Error as err:
    # Gérer les erreurs spécifiques à MySQL
    print(f"Erreur MySQL : {err}")

except Exception as e:
    # Gérer d'autres erreurs
    print(f"Une erreur s'est produite : {e}")

finally:
    # Assurez-vous de fermer le cursor, que l'opération réussisse ou échoue.
	if 'cursor' in locals() and cursor is not None:
        cursor.close()
	# Pareil pour la connexion.
    if 'conn' in locals() and conn.is_connected():
        conn.close()
```

<br>

### 2. Utilisation de Transactions

Les transactions sont un moyen de regrouper plusieurs opérations en une seule unité, garantissant que toutes réussissent ou échouent ensemble. Utilisez des transactions pour maintenir la cohérence des données.

```python
import mysql.connector

try:
    conn = mysql.connector.connect(
        host="localhost",
        user="votre_utilisateur",
        password="votre_mot_de_passe",
        database="ma_base_de_donnees"
    )

    cursor = conn.cursor()

    # Commencer une transaction
    conn.start_transaction()

    # Exécuter des opérations CRUD
    cursor.execute("UPDATE ma_table SET age = 26 WHERE nom = 'John Doe'")

    # Valider la transaction
    conn.commit()

except Exception as e:
    # En cas d'erreur, annuler la transaction
    conn.rollback()
    print(f"Une erreur s'est produite : {e}")

finally:
    if 'conn' in locals() and conn.is_connected():
        conn.close()
```

> [!INFO] Rollback
> Le rollback permet de revenir en arrière, on l'utilise dans le `except` pour annuler les toutes les modifications si une d'entre elles échouent.
> 
> Cela nous permet de ne pas avoir de MAJ partielle des données.

<br>

### 3. Utilisation de Paramètres dans les Requêtes

Évitez l'injection SQL en utilisant des paramètres dans vos requêtes plutôt que d'incorporer des valeurs directement dans la chaîne SQL.

```python
# Mauvaise pratique (risque d'injection SQL)
nom = "John Doe"
cursor.execute(f"SELECT * FROM ma_table WHERE nom = '{nom}'")

# Bonne pratique (utilisation de paramètres)
nom = "John Doe"
cursor.execute("SELECT * FROM ma_table WHERE nom = %s", (nom,))
```

<br>

### 4. Fermeture des Ressources Correctement

Assurez-vous de fermer correctement toutes les ressources, comme les connexions et les curseurs, pour éviter les fuites de ressources et garantir une utilisation efficace des ressources système.

```python
# Fermer le curseur
cursor.close()

# Fermer la connexion
conn.close()
```

<br>

### 5. Sécurité et Autorisations

Appliquez le principe du moindre privilège en définissant des autorisations spécifiques pour les utilisateurs de la base de données. Évitez d'utiliser des comptes ayant des droits excessifs.

<br>

### 6. Sauvegardes Régulières

Réalisez des sauvegardes régulières de votre base de données pour prévenir la perte de données en cas de problème.

<br>

## Modélisation des données avec SQLAlchemy

---

> [!INFO] Version SQLAchemy
> 
> Cette documentation est faites à partir de celle officielle.
> La version de la documentation est la 2.0 sortie ce 2 Novembre 2023

La modélisation des données est un aspect crucial de la gestion de bases de données. SQLAlchemy est une bibliothèque populaire qui offre un ORM (Object-Relational Mapping) pour simplifier la modélisation des données avec Python. 
Elle permet aussi de créer des requêtes implicite sans entrer de SQL en dur.

![sqlachemy architecture](https://docs.sqlalchemy.org/en/20/_images/sqla_arch_small.png)

<br>

### 1. Installation de SQLAlchemy

> [!Warning] version python
> Il faut au moins avoir la version 3.7 de python.
> 
> Conseillé : version 3.10+

```bash
pip install sqlalchemy
```

<br>

### 2. Connexion à la Base de Données

Pour nous connecter à la base de donnée, il va nous falloir créer un `engine`

> [!Warning] Dialecte et pilote
> Il faut faire un `pip install PyMySQL` afin de pouvoir créer l'engine

```python
from sqlalchemy import create_engine

# Spécifiez la connexion à la base de données (utilisez le format : 'mysql+pymysql://utilisateur:mot_de_passe@localhost/nom_de_la_base')
engine = create_engine('mysql+pymysql://votre_utilisateur:votre_mot_de_passe@localhost/ma_base_de_donnees')

# Établir la connexion
conn = engine.connect()
```

<br>

### 3. Définition d'un modèle avec SQLAlchemy

Ensuite pour définir un modèle, il va nous falloir hériter de `DeclarativeBase`.

```python
from typing import Optional
from sqlalchemy import String
from sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column

class Base(DeclarativeBase):
    pass

class User(Base):
    __tablename__ = "user_account"
    id: Mapped[int] = mapped_column(primary_key=True)
    name: Mapped[str] = mapped_column(String(30))
    fullname: Mapped[Optional[str]] = mapped_column(String(50))
    
    def __repr__(self) -> str:
        return f"User(id={self.id!r}, name={self.name!r}, fullname={self.fullname!r})"
```

<br>

### 4. Création des tables

```python
# Créer la table
Base.metadata.create_all(engine)  # Base est la table vide qu'on a créé plus tôt.
```

Vous pouvez maintenant utiliser le modèle pour effectuer des opérations CRUD de manière plus abstraite.

<br>

### 5. CRUD avec SQLAlchemy

Afin d'ajouter des informations dans notre base de donnée, on doit ouvrir une `Session` qui prendra `engine` en paramètre afin de regrouper plusieurs instructions et les exécuter au moment du `session.commit()` pour actualiser la base de donnée.

- **Création (Create) :**
```python
from sqlalchemy.orm import Session

with Session(engine) as session:
    spongebob = User(name="spongebob", fullname="Spongebob Squarepants")
    sandy = User(name="sandy", fullname="Sandy Cheeks")
    patrick = User(name="patrick", fullname="Patrick Star")
    
    session.add_all([spongebob, sandy, patrick])
    session.commit()
```

- **Lecture (Read) :**
```python
from sqlalchemy import select

# Lire des données dans la table
stmt = select(User).where(User.name.in_(["spongebob", "sandy"]))

# Le scalar est un wrapper pour obtenir une liste de résultat
for user in session.scalars(stmt):
	print(user)

# RESULTAT
# User(id=1, name='spongebob', fullname='Spongebob Squarepants')
# User(id=2, name='sandy', fullname='Sandy Cheeks')
```

- **Lecture avec jointure (Read) :**
```python
from sqlalchemy import select

stmt = (
    select(Address)
    .join(Address.user)
    .where(User.name == "sandy")
    .where(Address.email_address == "sandy@sqlalchemy.org")
)

sandy_address = session.scalars(stmt).one()
print(sandy_address)

# RESULTAT
# Address(id=2, email_address='sandy@sqlalchemy.org')
```

- **Mise à Jour (Update) :**
```python
from sqlalchemy import select

# récupération
stmt = select(User).where(User.name == "patrick")
patrick = session.scalars(stmt).one()

# modification
patrick.addresses.append(Address(email_address="patrickstar@sqlalchemy.org"))
sandy_address.email_address = "sandy_cheeks@sqlalchemy.org"

# sauvegarde
session.commit()
```

> [!TIPS] Mise a jour automatique
> 
> la mise a jour des clé étrangère dans les tables peut se faire automatiquement si vous avec mis `onupdate="cascade"` dans la définition de la **ForeignKey**

- **Suppression (Delete) :**
```python
from sqlalchemy import select

sandy = select(User).where(User.id == 2) # récupérer
sandy.addresses.remove(sandy_address)  # modifier
session.flush()  # actualiser

# Supprimer des données de la table
# ne pas oublier de scalar
session.delete(patrick)
session.commit()
```

> [!TIPS] Mise a jour automatique
> 
> la mise a jour des clé étrangère dans les tables peut se faire automatiquement si vous avec mis `ondelete="CASCADE"` dans la définition de la **ForeignKey

### 6. Fermeture de la Connexion

N'oubliez pas de fermer la connexion une fois vos opérations terminées.

```python
# Fermer la connexion
session.close()
```

<br>

[Exercice 2](3.%20Exercices%20accès%20BDD.md#Exercice%202)

<br>

## 7. Les différentes relations des tables

---

Il existe aussi plein de façon différentes de relier les tables entre elles en mono ou bi-directionnel.

Pour passer de mono en bi-directionnel, il faut ajouter des `back_populates` sur l'attribut de la table ciblé.

### One to many

relation la plus fréquence dans la représentation des bases de données.

- mono-directionnel
```python
class Parent(Base):
    __tablename__ = "parent_table"

    id: Mapped[int] = mapped_column(primary_key=True)
    children: Mapped[List["Child"]] = relationship()


class Child(Base):
    __tablename__ = "child_table"

    id: Mapped[int] = mapped_column(primary_key=True)
    parent_id: Mapped[int] = mapped_column(ForeignKey("parent_table.id"))
```

- bi-directionnel
```python
class Parent(Base):
    __tablename__ = "parent_table"

    id: Mapped[int] = mapped_column(primary_key=True)
    children: Mapped[List["Child"]] = relationship(back_populates="parent")


class Child(Base):
    __tablename__ = "child_table"

    id: Mapped[int] = mapped_column(primary_key=True)
    parent_id: Mapped[int] = mapped_column(ForeignKey("parent_table.id"))
    parent: Mapped["Parent"] = relationship(back_populates="children")
```

<br>

### Many to one

C'est exactement la même chose que le one to many, sauf que l'ordre de la relation est inversé.

- mono-directionnel
```python
class Parent(Base):
    __tablename__ = "parent_table"

    id: Mapped[int] = mapped_column(primary_key=True)
    child_id: Mapped[int] = mapped_column(ForeignKey("child_table.id"))
    child: Mapped["Child"] = relationship()


class Child(Base):
    __tablename__ = "child_table"

    id: Mapped[int] = mapped_column(primary_key=True)
```

- bi-directionnel et nullable  (python 3.10)
```python
from __future__ import annotations


class Parent(Base):
    __tablename__ = "parent_table"

    id: Mapped[int] = mapped_column(primary_key=True)
    child_id: Mapped[int | None] = mapped_column(ForeignKey("child_table.id"))
    child: Mapped[Child | None] = relationship(back_populates="parents")


class Child(Base):
    __tablename__ = "child_table"

    id: Mapped[int] = mapped_column(primary_key=True)
    parents: Mapped[List[Parent]] = relationship(back_populates="child")
```

<br>

### One to one

Relation d'appartenance, une entité possède une autre entité. On peux choisir dans lequel des 2 cotés on souhaite stocké l'id de l'autre.

```python
class Parent(Base):
    __tablename__ = "parent_table"

    id: Mapped[int] = mapped_column(primary_key=True)
    child: Mapped["Child"] = relationship(back_populates="parent")


class Child(Base):
    __tablename__ = "child_table"

    id: Mapped[int] = mapped_column(primary_key=True)
    parent_id: Mapped[int] = mapped_column(ForeignKey("parent_table.id"))
    parent: Mapped["Parent"] = relationship(back_populates="child")
```

<br>

### Many to many

pour cette partie, pour éviter du code en impératif, on va utiliser des tables d'associations.

- mono-directionnal
```python
from typing import Optional
from sqlalchemy import ForeignKey, Integer
from sqlalchemy.orm import Mapped, mapped_column, DeclarativeBase, relationship

class Base(DeclarativeBase):
    pass

class Association(Base):
    __tablename__ = "association_table"
    left_id: Mapped[int] = mapped_column(
	    ForeignKey("left_table.id"), primary_key=True
	)
    right_id: Mapped[int] = mapped_column(
        ForeignKey("right_table.id"), primary_key=True
    )
    extra_data: Mapped[Optional[str]]
    child: Mapped["Child"] = relationship()

class Parent(Base):
    __tablename__ = "left_table"
    id: Mapped[int] = mapped_column(primary_key=True)
    children: Mapped[List["Association"]] = relationship()

class Child(Base):
    __tablename__ = "right_table"
    id: Mapped[int] = mapped_column(primary_key=True)
```

- bi-directionnal
```python
from typing import Optional
from sqlalchemy import ForeignKey, Integer
from sqlalchemy.orm import Mapped, mapped_column, DeclarativeBase, relationship

class Base(DeclarativeBase):
    pass

class Association(Base):
    __tablename__ = "association_table"

    left_id: Mapped[int] = mapped_column(
	    ForeignKey("left_table.id"), primary_key=True
	)
    right_id: Mapped[int] = mapped_column(
        ForeignKey("right_table.id"), primary_key=True
    )
    extra_data: Mapped[Optional[str]]

    # association between Assocation -> Child
    child: Mapped["Child"] = relationship(back_populates="parent_associations")

    # association between Assocation -> Parent
    parent: Mapped["Parent"] = relationship(back_populates="child_associations")


class Parent(Base):
    __tablename__ = "left_table"

    id: Mapped[int] = mapped_column(primary_key=True)

    # many-to-many relationship to Child, bypassing the `Association` class
    children: Mapped[List["Child"]] = relationship(
        secondary="association_table", back_populates="parents"
    )

    # association between Parent -> Association -> Child
    child_associations: Mapped[List["Association"]] = relationship(
        back_populates="parent"
    )


class Child(Base):
    __tablename__ = "right_table"

    id: Mapped[int] = mapped_column(primary_key=True)

    # many-to-many relationship to Parent, bypassing the `Association` class
    parents: Mapped[List["Parent"]] = relationship(
        secondary="association_table", back_populates="children"
    )

    # association between Child -> Association -> Parent
    parent_associations: Mapped[List["Association"]] = relationship(
        back_populates="child"
    )


# UTILISATION
p1 = Parent()
c1 = Child()
p1.children.append(c1)
```

<br>

## Le retour en POO SQLAlchemy

---

### Enum (énumération)

En plus de l'écrire en littéral, il est possible de créer une collection de type dans une classe afin de limiter les actions possibles.

```python
import enum
from sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column

class Base(DeclarativeBase):
    pass

class Status(enum.Enum):
    PENDING = "pending"
    RECEIVED = "received"
    COMPLETED = "completed"

class SomeClass(Base):
    __tablename__ = "some_table"

    id: Mapped[int] = mapped_column(primary_key=True)
    status: Mapped[Status]
```

### Encapsulation de pseudo attribut

Il est possible aussi de faire des méthodes pour englober plusieurs attribut et le gérer comme un pseudo nouvel attribut, plutôt que d'en créer un.

```python
from sqlalchemy.ext.hybrid import hybrid_property
from sqlalchemy.sql import case
from sqlalchemy import Integer
from sqlalchemy.orm import mapped_column


class User(Base):
    __tablename__ = "user"
    id = mapped_column(Integer, primary_key=True)
    firstname = mapped_column(String(50))
    lastname = mapped_column(String(50))

    @hybrid_property
    def fullname(self):
        if self.firstname is not None:
            return self.firstname + " " + self.lastname
        else:
            return self.lastname

    @fullname.expression
    def fullname(cls):
        return case(
            (cls.firstname != None, cls.firstname + " " + cls.lastname),
            else_=cls.lastname,
        )
```

On peux aussi faire des classes abstraites. afin d'avoir un traitement généralisé ou juste un typage pour les Collections plus dynamique.

```python
from sqlalchemy.orm import DeclarativeBase

class Base(DeclarativeBase):
    pass

class Employee(Base):
    __abstract__ = True

class Manager(Employee):
    __tablename__ = "manager"
    id = mapped_column(Integer, primary_key=True)
    name = mapped_column(String(50))
    manager_data = mapped_column(String(40))

class Engineer(Employee):
    __tablename__ = "engineer"
    id = mapped_column(Integer, primary_key=True)
    name = mapped_column(String(50))
    engineer_info = mapped_column(String(40))
```

On peut aussi ajouter des condition de validation, soit avec un `validator` soit avec des `getters/setters`

> Validator

```python
from sqlalchemy.orm import validates


class EmailAddress(Base):
    __tablename__ = "address"

    id = mapped_column(Integer, primary_key=True)
    email = mapped_column(String)

    @validates("email")
    def validate_email(self, key, address):
        if "@" not in address:
            raise ValueError("failed simple email validation")
        return address
```

> getters / setters

```python
class EmailAddress(Base):
    __tablename__ = "email_address"

    id = mapped_column(Integer, primary_key=True)
    _email = mapped_column("email", String)

    @property
    def email(self):
        return self._email

    @email.setter
    def email(self, email):
        self._email = email
```

Grace à la `session` qui garde tout en mémoire, on peut faire un `rollback` si le programme plante et éviter des modifications qui se font que à moitié sur la base de donnée.

```python
import gevent

try:
    sess = Session()
    sess.add(User())
    sess.commit()
except gevent.Timeout:
    sess.invalidate()
    raise
except:
    sess.rollback()
    raise
```

<br>

## Aller plus loin avec SQLAlchemy

---

Il existe plusieurs façon différentes 

| ORM                                         |   Core                                     |
|---------------------------------------------|--------------------------------------------|
|sessionmaker                                 | Engine                                     |
|Session                                      | Connection                                 |
|sessionmaker.begin()                         | Engine.begin()                             |
|some_session.commit()                        | some_connection.commit()                   |
|with some_sessionmaker() as session:         | with some_engine.connect() as conn:        |
|with some_sessionmaker.begin() as session:   | with some_engine.begin() as conn:          |
|with some_session.begin_nested() as sp:      | with some_connection.begin_nested() as sp: |

> on passe de ce code avec le CORE :

```python
engine = create_engine("postgresql+psycopg2://user:pass@host/dbname")

with engine.connect() as conn:
    conn.execute(
        some_table.insert(),
        [
            {"data": "some data one"},
            {"data": "some data two"},
            {"data": "some data three"},
        ],
    )
    conn.commit()
```

> A ce code avec l'ORM

```python
Session = sessionmaker(engine)

with Session() as session:
    session.add_all(
        [
            SomeClass(data="some data one"),
            SomeClass(data="some data two"),
            SomeClass(data="some data three"),
        ]
    )
    session.commit()
```

Il est d'avoir plusieurs connexion à des bases de données différentes dans la même session.

```python
engine1 = create_engine("postgresql+psycopg2://db1")
engine2 = create_engine("postgresql+psycopg2://db2")

Session = sessionmaker()

# bind User operations to engine 1, Account operations to engine 2
Session.configure(binds={User: engine1, Account: engine2})

session = Session()
```

Comme il est possible d'avoir des attribut qui sont le résultat de requête base de donnée.

```python
from sqlalchemy import and_

class Author(Base):
    # ...

    book_count = column_property(
        select(func.count(books.c.id))
        .where(
            and_(
                book_authors.c.author_id == authors.c.id,
                book_authors.c.book_id == books.c.id,
            )
        )
        .scalar_subquery()
    )
```
